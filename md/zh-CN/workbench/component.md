## 组件开发

本章着重讲解组件开发的具体流程，以及组件所具备的各类属性与方法。

### 概述

在前端项目开发中，组件开发占据着举足轻重的地位。通过组件封装，能够将公共业务或 UI 交互进行统一整合，有效避免重复开发，极大地提高开发效率。

JOKER 开发平台展现出卓越的优势，它支持在线进行组件开发，且开发完成的组件无需经过编译，即可在平台内直接引用并渲染。这得益于 JOKER 开发平台自主研发的渲染与沙箱机制，实现了框架层面的高度灵活性。

一个完整的组件主要由以下几大功能点构成：

-   **状态数据**：此部分用于维护组件的数据，涵盖传入参数、响应式数据以及内部私有变量。传入参数让组件可接收外部传递的数据，提升组件的通用性；响应式数据能实时响应数据变化，确保组件界面及时更新；内部私有变量用于组件内部逻辑处理，保障数据的安全性与独立性。
-   **生命周期**：组件从创建到销毁的过程中，会提供不同阶段的钩子函数。开发者可借助这些钩子函数，在组件生命周期的各个阶段执行特定的业务逻辑。比如，在组件创建时进行数据初始化，在销毁时清理相关资源，以此确保组件正常运行和资源合理管理。[组件生命周期](https://front.jokers.pub/base/component-lifecycle)
-   **方法逻辑**：开发者可在此创建公开或私有方法。公开方法可供外部调用，便于其他组件或模块与该组件交互，实现功能的复用与扩展；私有方法用于组件内部逻辑处理，保证组件内部逻辑的封装性与独立性。
-   **事件处理**：事件主要分为组件/元素事件和组件内部事件两种类型。组件/元素事件用于响应用户对组件或元素的操作，如点击、鼠标移动等；组件内部事件用于组件内部各部分之间的通信与交互，确保组件内部逻辑的连贯性与协同性。
-   **组件布局**：开发者能够通过可视化拖拽的方式管理组件布局，同时可配置组件的属性、区块以及事件。此外，平台提供的大纲树功能，能以更直观的方式帮助开发者查看和管理组件结构，让组件布局的设计与调整更加便捷高效。

若您希望深入了解组件开发的底层细节，可查阅[核心框架](https://front.jokers.pub/base/component)文档。

### 状态数据

![](/workbench/component.png)

当打开一个`组件`或`页面`文件时，工作台左侧菜单中会显示`组件数据`菜单，点击后即可打开组件数据面板。

从数据使用的角度出发，可将其分为以下几类：

-   **传入参数（props）**：这是当前组件所需要的参数。这些参数具有响应式特点，一旦外部使用者传递的参数发生变化，会立即通知并更新组件内部的 DOM 节点。这意味着，组件能够实时响应外部传入数据的变动，从而动态调整自身的显示与行为，大大增强了组件的灵活性与复用性。例如，一个按钮组件可能通过 props 接收按钮的文本内容、颜色等参数，当外部传入的文本或颜色改变时，按钮能立刻呈现相应的变化。

-   **响应数据（model）**：这是组件内部的响应数据。在组件装载开始前，该属性会被“劫持”，进而具备数据响应能力。也就是说，当这个内部数据发生改变时，与之相关联的组件部分会自动更新。比如在一个购物车组件中，商品数量作为响应数据，当数量改变时，购物车的总价显示、商品列表的渲染等相关部分会自动更新，为用户提供实时反馈。

-   **内部私有属性**：这类属性既不支持外部调用，也不具备响应式能力，仅作为组件内部临时使用的变量。在这里，你可以声明内部动态数据变量，方便在多个方法中使用。例如，在一个复杂的表单组件中，可能需要一个临时变量来记录表单填写的步骤状态，这个变量只在组件内部的方法中使用，无需对外暴露，也不需要对其变化做出响应式更新。

### 生命周期

我们可以在`组件数据`面板中的`逻辑/事件 - 生命周期`中来管理我们的组件生命周期。当我们生命周期右侧的加号按钮后，可以添加生命周期函数。添加后，我们即可在这里维护我们的生命周期逻辑了。（逻辑编排帮助文档可以在[这里](/workbench/workflow)中查看。）
![](/workbench/component2.png)

一个组件或者页面，从创建到销毁是由完整的一套生命周期函数的，我们可以通过这些函数来实现在不同节点中的业务处理。[组件生命周期](/workbench/component-life)

### 方法逻辑

我们能够在`组件数据`面板的`逻辑/事件 - 组件方法`区域对组件方法进行管理。

![组件方法管理面板截图](/workbench/component3.png)

在创建方法时，可依据具体使用场景决定该方法是否对外开放：

-   **私有方法**：仅供组件内部使用，主要用于处理组件内部的业务逻辑。它就像组件内部的“秘密武器”，专注于完成组件内部特定的任务，不会对外暴露接口，保证了组件内部逻辑的封装性和独立性。
-   **公共方法**：既可以在组件内部使用，也能对外提供调用能力。这使得组件之间能够进行有效的交互和协作，增强了组件的复用性和扩展性。

当我们将某个方法设置为对外公开后，可以通过`ref`的方式调用该方法。这里仅作简单演示，若想了解详细内容，可查看[组件方法](/workbench/component-method)、[组件布局](/workbench/component-layout)文档。

![公开方法调用演示截图](/workbench/component5.png)

值得一提的是，平台会自动分析公开方法的参数类型和返回类型，并提供可视化的方法调用界面，极大地提升了开发的便捷性，让开发者能够更轻松地使用和管理组件方法。

### 事件处理

我们可以在`组件数据`面板的`逻辑/事件 - 对外事件/内部事件`区域对组件事件进行管理，同时，这里也是查看组件事件相关信息的重要入口。

![组件事件信息面板截图](/workbench/component6.png)

在此区域，我们能够查看当前组件关于事件的所有信息，这些事件主要分为两类：

-   **对外事件**：这是当前组件对外提供的事件处理机制。需要注意的是，该功能仅在组件文件中存在，页面文件不会对外触发此类事件。对外事件使得组件可以与外部进行有效的交互，当组件内部发生特定情况时，能够向外部发送信号，通知其他部分做出相应的响应。例如，一个自定义的下拉菜单组件，当用户选择了某个菜单项时，可以通过对外事件通知父组件进行数据更新等操作。
-   **内部事件**：主要是对当前组件内的模板节点进行监听的事件处理。比如，一个按钮的点击事件就属于内部事件。通过监听这些内部事件，我们可以在组件内部实现各种交互逻辑，当用户与组件内的元素进行交互时，触发相应的处理函数，完成特定的任务，如显示提示信息、修改组件状态等。

若想了解关于组件事件的详细内容，可查看[组件事件](/workbench/component-event)文档。

### 组件布局

组件布局是组件/页面开发中最为重要的环节之一，我们可以通过工作画布实现对组件/页面的布局编排，实现组件的展现开发。

在前端编辑器中，界面分为左右两个区域，即 `开发画布区` 和 `属性区`。

![前端编辑器截图](/workbench/front-end2.png)

1. **开发画布区**：在此区域，我们能够将 **组件** 拖入工作画布，完成组件的添加操作。同时，若已添加组件，选中它后可对其属性进行修改，或者执行删除该组件等操作。
2. **属性区**：当未选中任何组件时，默认展示的是组件属性面板。在此，我们既可以更改组件的样式文件，也能够通过 HTML 快速导入节点。而当选中组件时，属性区会呈现该组件的专属属性面板，此面板包含 `属性`、`事件`、`区域` 这三个类型的属性配置。

#### 如何添加组件

平台允许我们通过拖拽的方式添加组件。

-   组件中心：我们可以在`组件中心`中通过拖拽的方式实现对组件的引用。
    [video](/workbench/component4.mp4)
-   资源管理器：我们可以在资源管理中，通过推拽**组件**类型的文件实现对项目内组件文件的引用。
    [video](/workbench/component7.mp4)
-   布局快速添加：当我们选中一个组件时，我们可以在组件点击`快速添加`打开快速添加组件面板，实现对组件的快速引用。
    [video](/workbench/component8.mp4)

#### 如何配置组件

我们可以在画布中通过点击的方式来选择某个组件，选中组件后，我们可以在画布左侧面板中查看当前组件的配置信息，并在这里修改组件的参数，包括：组件参数、组件事件、组件区块。

![](/workbench/component9.png)

#### 组件样式

平台赋予了用户对单个组件进行样式编写的能力。用户可运用嵌套 CSS 语法完成组件样式的编写，平台默认支持 `scoped` 样式隔离，有效避免样式冲突。同时，也提供 `deep()` 样式穿透功能，满足特定场景下样式覆盖的需求。

当我们在画布中未选中任何组件时（可在画布下方的快捷操作面板中点击取消选中组件），画布左侧会显示当前组件的属性面板，在这里我们可以维护我们组件的样式：

![](/workbench/component10.png)

#### 大纲树

平台具备整体布局大纲展示功能，您能够在`组件数据`面板的`大纲树`里查看布局结构。此外，该大纲树还提供了丰富的快捷布局操作，助您更高效地完成布局调整。
![](/workbench/component11.png)

> 详细的组件布局，请参考[组件布局](/workbench/component-layout)。
