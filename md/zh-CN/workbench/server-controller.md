## 控制器设计

本章着重阐述控制器相关内容。控制器作为服务端应用的核心功能模块，承担着设计应用 API 接口的重任，堪称服务端应用唯一请求入口的设计枢纽。

### 概要

平台赋予我们通过可视化方式，快速创建服务端应用 API 接口的能力。我们能够在`控制器`文件夹内，依据业务类型创建不同的控制器，并且每个控制器下可创建多个 API 方法。
![](/workbench/back-end.png)

接下来，我们将按照“API 创建 -> 输入参数 -> API 方法参数 -> API 方法返回值类型 -> 鉴权”的顺序，详尽讲解控制器的各项功能。

### 创建 API

在控制器文件中，可创建多个 API 方法。点击右上角的**创建 API**按钮，即可打开 API 编辑器窗口。
![](/workbench/server-controller.png)

在此窗口中，可对 API 接口的以下信息进行配置：

-   **名称**：即接口 API 方法的名称。需注意，此并非最终的 API 访问地址，API 的访问地址格式为`服务文根`/`控制器名称`/`API 名称`。
-   **备注标题**：为 API 方法配置别名，助力开发人员迅速明晰 API 的含义。
-   **描述**：为 API 方法撰写详细的说明信息，方便开发人员深入领会。
-   **请求类型**：在此可配置多种请求类型，仅符合所配置请求类型的请求，才会映射到该 API 方法。其可选值包括：**POST**、**GET**、**PUT**、**DELETE**。
-   **授权认证**：若开启此功能，在访问该 API 接口前，系统会对 JWT 进行认证。一旦 JWT 验证失败或过期，将直接返回 401 错误。
-   **输入参数**：在此处能够配置 API 的输入参数。

### 输入参数校验

如前文所述，我们可在 API 接口编辑面板中创建 API 接口的输入参数，其创建遵循通用的`字段维护`规则，详细内容可查阅[字段维护](/workbench/property)章节。

在此，主要讲解 API 输入参数在字段维护中的一项特殊功能：**输入参数校验**。

在**字段维护**编辑窗口的第二步，通过选择不同的数据类型，能够配置各异的字段限制规则。
![](/workbench/server-controller1.png)

以下是不考虑数据类型时，所有的校验规则介绍：

1. **正则校验**：允许自定义正则表达式，以此约束输入参数的内容。
2. **是否为邮箱**：用于验证输入内容是否为邮箱格式。
3. **是否为电话**：判断输入内容是否符合电话格式。
4. **只限字母**：确保输入内容仅包含字母。
5. **只限字母和数字**：限定输入内容只能是字母和数字。
6. **只限数字**：仅允许输入数字（字符串类型数字）。若该字段本身即为数字类型，可直接更改字段类型；此规则仅为字符串类型提供数字格式的校验补充。
7. **是否是整数**：要求输入必须是整数，不允许为浮点数。
8. **包含特定内容**：字符串中必须包含特定的内容。
9. **限制值范围**：对值的范围进行限制。例如性别只能是男/女，支持手动维护枚举值，也可选择数据表内的枚举值。
   ![](/workbench/server-controller2.png)
10. **长度限制**：对字符串长度进行限制，可单独配置最大值或最小值，也能同时组合限制。
11. **最大值**：针对数字类型的字段，可配置最大值限制。
12. **最小值**：针对数字类型的字段，可配置最小值限制。
13. **文件大小限制**：当字段类型为**File**文件时，可通过此约束来限定上传文件的大小。
14. **文件格式限制**：当字段类型为**File**文件时，可限制文件的最大上传数量，默认仅允许上传 1 个文件。
15. **文件类型限制**：当字段类型为**File**文件时，可限制上传文件的接收类型，支持通配符。例如：图片(image/jpeg,image/\*)支持“\*”通配符，若需限制多个类型，可用“,”进行分割。

### 文件上传

在服务端项目中，`字段维护`面板支持选择字段类型为`File`文件类型，借助此功能，我们能够在 API 接口中实现文件上传。

上文提及了文件类型的约束条件配置，在此着重讲解 File 类型具备的属性及操作方式。
![](/workbench/server-controller3.png)

假设创建了一个输入参数`userImg`，可通过`data.userImg`的方式获取上传的文件，并对其展开操作。

文件类型的数据为我们提供了以下属性：
| 名称 | 类型 | 描述 |
| ------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| checkMimeType | Function | 检查是否符合文件类型要求，支持通配符。例如：图片(image/jpeg,image/\*)支持“\*”通配符，若限制多个类型，可以是单个字符串也可以是字符串数组 |
| checkSize | Function | 检查是否满足文件大小限制 |
| fileCount | Number | 文件个数 |
| files | File[] | 所有文件 |
| save | Function | 通过该方法实现文件保存到服务端指定目录 |

在此，重点讲解**save**文件保存方法。其他属性通常可在输入项条件约束中进行配置，除非存在特殊需求，才会考虑使用自定义方式判断文件格式、文件大小。

#### 文件保存

```js
//不做任何调整直接保存到项目上传目录中
await data.userImg.save();

//完整参数示例,将文件保存到上传目录中的user文件夹中。
await data.userImg.save("user/", {
    //自定义保存文件名
    newFileName: (file) => {
        //按照userId.ext的格式进行命名，其中file.ext 是上传的文件扩展名
        return userId + "." + file.ext;
    },
    //是否不压缩图片，这里默认为false，默认平台底层会对上传的图片资源做压缩处理，若不想压缩可以配置为true
    uncompressedImage: false,
    //图片压缩处理配置，仅在开启图片压缩时生效
    imageCompressionOption: {
        //图片压缩比率0 - 100,默认80
        quality: 80,
        //图片最大宽度，默认不限制，单位像素，若配置值小于实际图片值则会等比例缩放
        maxWidth: 1000,
        //图片最大高度，默认不限制，单位像素，若配置值小于实际图片值则会等比例缩放
        maxHeight: 1000
    }
});
```

> 其中项目上传目录可在服务端环境变量中，通过**UPLOAD_ROOT_DIR**进行配置。

#### 保存返回值

**save**方法的调用为异步操作，其返回值是一个数组：

```typescript
{
    //成功保存的文件列表，值为保存的路径
    success: string[];
    //保存失败的错误信息列表
    error: string[];
}
```

完整实例：

```js
//不做任何调整直接保存到项目上传目录中
let uploadResult = await data.userImg.save();

if (uploadResult.error.length) {
    //TODO：记录日志
    return ActionError("保存失败"); //ActionError 在 API返回值类型有介绍。
}

let userImg = uploadResult.success[0];
```

![](/workbench/server-controller4.png)

### API 方法参数

在 API 逻辑编排中，平台为我们提供了常用的数据参数。

-   data： 输入参数，类型可以在 API 接口输入参数中去设计维护。
-   context：路由上下文，是 API 接口处理的路由上下文数据，里面包含：
    1. jwt：鉴权令牌内容，若当前控制器开启了**鉴权**，才会存在 jwt 属性，令牌值已解析，可以直接获取内部属性。
    2. url：请求地址
    3. request：底层请求对象，我们可以通过它获取请求 IP、来源地址等数据。
    4. logger：日志处理对象，可以帮助我们实现集中日志输出和收集。
-   logger：日志处理对象，可以帮助我们实现集中日志输出和收集。他和 console 不同的是，他是集中的日志收集器，它允许我们使用文件日志、控制台日志、数据库日志。根据不同的需求可以在[环境配置](/workbench/env)中进行配置。

### API 返回值类型

平台为我们提供了统一的数据返回结构，如下所示：

```json
{
    "header": {
        "code": "状态码", // 当返回 JK000000 时代表业务成功，除此之外全部为业务异常
        "msg": "错误信息"
    },
    "data": {} // 返回的业务数据
}
```

平台还提供了快速创建接口返回值的方法：

#### Ok

用于返回正确的业务数据。示例代码如下：

```js
return Ok(业务数据);
```

当然，也可以在逻辑编排面板中，使用**返回成功数据**节点来实现正确业务数据的返回。
![](/workbench/server-controller5.png)

#### ActionError

用于返回异常业务数据。示例代码如下：

```js
return ActionError(错误信息, 错误码, 业务数据);
// 其中错误信息为必填项，错误码若不配置则使用通用异常码 JK999999。
```

> 开发人员可配置不同的错误码，以便前端在请求异常时，能根据状态码实现不同的业务处理分支。

同样，也可以在逻辑编排面板中，使用**返回失败数据**节点来返回异常业务数据。
![](/workbench/server-controller6.png)

#### 数据兜底

在控制器中，我们可以直接通过`return`返回业务数据。平台底层会进行判断，若返回的数据符合要求的 API 数据格式，则按照该返回值进行返回；否则，将自动包裹`Ok`方法，将其作为正确数据返回。

### 授权认证

接下来，详细讲解如何配置项目的 JWT 令牌功能。

#### 如何生成 JWT 令牌

可以在某个 API 接口中生成 JWT 令牌，并将其返回给前端，通常在登录接口中完成这一操作。

可使用`generateJwtToken`方法来生成令牌。
![](/workbench/server-controller7.png)

从上图的逻辑可知，首先依据接口输入项查询用户信息。若查询到用户信息，就使用该信息生成 JWT，并返回`Ok`；若未查询到用户信息，则返回`ActionError`。

> 上述内容仅为示例，特别提醒，切勿在 JWT 内容中存放敏感数据，如密码等。

#### 前端如何上送 JWT 令牌

前端需在接口请求头`header`中，通过**sid**来上送 JWT 令牌。

在 JOKER 可视化平台中，可在`transformReqData`数据请求转换方法里统一注入`sid`。
![](/workbench/server-controller8.png)

> 这里需要特别注意，若 API 开启了**鉴权**功能，在 API 方法内通过`context.jwt`获取的值即为 JWT 的`payload`。此时，无需使用`verifyJwtToken`方法来检验令牌的合法性，因为平台会在路由切面中预先判断令牌是否合法。若令牌无效，将不会执行 API 内的逻辑。`verifyJwtToken`方法仅用于高级复杂的自定义校验场景，为其提供令牌的解析操作。
