<template>
<div ref='container' class='joker-demo-container'>
<h2>环境变量</h2>
<p>本章主要介绍<code>应用</code>类型项目中的环境变量相关功能。</p>
<h3>概述</h3>
<p>在应用类型中的项目中，平台允许我们通过环境变量的方式实现多环境的业务/运行差异。
我们可以在根目录中的<strong>环境变量</strong>文件维护项目的环境变量。
<img src="/workbench/env.png" alt=""></p>
<ul>
<li><strong>环境变量</strong>：我们可以在该文件中创建环境变量，并在不同的环境中为其设置不同的值。</li>
<li><strong>环境</strong>：我们可以根据自身要求创建多个环境，每个环境中可以为环境变量配置不同的值。通常，环境分为：
<ul>
<li><strong>DEV（开发环境，Development Environment）</strong>：开发人员日常编写代码、调试程序的环境，侧重于便捷开发，与生产环境有较大差异，方便开发人员快速迭代和修改代码。</li>
<li><strong>IT（集成测试环境，Integration Testing Environment）</strong>：用于多个组件或模块的集成测试，重点验证不同模块间的交互与协作，确保系统集成后功能完整、稳定，检测组件间接口是否正常。</li>
<li><strong>SIT（系统集成测试环境，System Integration Testing Environment）</strong>：对整个系统开展集成测试，把各个子系统、功能模块整合，测试系统整体性能、功能兼容性及与外部系统的交互，保证系统满足业务需求和设计要求。</li>
<li><strong>UAT（用户验收测试环境，User Acceptance Testing Environment）</strong>：交付项目前，供最终用户或客户进行验收测试，以此验证系统是否契合业务需求和用户期望，确保系统上线前获得用户认可。</li>
<li><strong>STAGING（预发布环境）</strong>：也叫灰度环境，配置和数据与生产环境极为相似，主要在新版本部署到生产环境前，进行最后的集成测试、性能测试和预发布验证，降低上线风险，保障新版本在生产环境稳定运行。</li>
<li><strong>QA（质量保证环境，Quality Assurance Environment）</strong>：质量保证人员执行各类测试的环境，涵盖功能、性能、安全等多方面测试，模拟多样用户场景和数据条件，全面保障系统质量和稳定性。</li>
<li><strong>PROD（生产环境，Production Environment）</strong>：系统正式运行，面向最终用户提供服务的环境，生产数据在此处理和存储，对稳定性、可靠性和安全性要求极高。</li>
</ul>
</li>
</ul>
<h3>默认变量</h3>
<p>平台为我们提供了基本的环境变量，这些变量不允许被删除。接下来我们分别讲解下<strong>前端</strong>、<strong>服务端</strong>项目中默认变量的含义。</p>
<h4>前端项目</h4>
<table class="mkd-table">
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requesterRoot</code></td>
<td>请求文根</td>
<td>用于配置请求地址。当发起请求时，实际请求地址将由<code>请求文根</code>与<code>请求api地址</code>组合而成，格式为<code>请求文根</code>/<code>请求api地址</code>。</td>
</tr>
<tr>
<td><code>enableRequesterMock</code></td>
<td>是否开启请求 Mock</td>
<td>该配置项决定是否启用请求的 Mock 功能。开启后，请求不会发送至服务端，而是在终端使用 Mock 数据返回接口数据。取值说明：- <code>true</code>：开启 Mock 功能；- <code>false</code>：关闭 Mock 功能；- 若不填写，默认值为<code>true</code>，即开启 Mock 功能。</td>
</tr>
<tr>
<td><code>routerRoot</code></td>
<td>路由文根</td>
<td>可用于配置路由地址的文根。如需了解更多详细内容，可参考<a href="https://front.jokers.pub/router/init" target="_blank">路由</a>中的<strong>base</strong>路由根相关内容。</td>
</tr>
</tbody>
</table>
<h4>服务端项目</h4>
<table class="mkd-table">
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SERVER_NAME</code></td>
<td>服务名</td>
<td>当服务采用集群部署时，可通过该属性配置各个服务节点的名称。在进行日志记录时，会记录此服务名称，方便对不同服务节点的日志进行区分和管理。</td>
</tr>
<tr>
<td><code>PORT</code></td>
<td>服务端口</td>
<td>服务所使用的端口，默认值为 8000。可根据实际需求修改，以避免端口冲突或适应特定的网络环境。</td>
</tr>
<tr>
<td><code>HOST</code></td>
<td>服务地址根</td>
<td>服务的基础地址，默认为 <code>localhost</code>。通常用于指定服务在网络中的访问位置，可根据部署环境进行调整。</td>
</tr>
<tr>
<td><code>UPLOAD_ROOT_DIR</code></td>
<td>文件上传目录</td>
<td>文件上传时所使用的存储目录，默认设置为当前运行目录下的 <code>upload</code> 文件夹。可根据实际存储需求，将其配置到其他合适的磁盘位置。</td>
</tr>
<tr>
<td><code>STATIC_ROOT_DIR</code></td>
<td>静态资源服务文件目录</td>
<td>用于配置静态资源文件（如图片、CSS、JavaScript 文件等）的存储目录。配置后，在启动服务接口的同时，会将该配置目录作为静态服务启动，方便前端直接访问这些静态资源。</td>
</tr>
<tr>
<td><code>AUTH_EXPIRES_IN</code></td>
<td>默认 JWT 令牌过期时间</td>
<td>可配置 JWT（JSON Web Token）令牌的有效时长，并支持设置时间单位。例如，<code>24h</code> 表示 24 小时，<code>3d</code> 表示 3 天。若不进行配置，默认过期时间为 4 天。</td>
</tr>
<tr>
<td><code>LOG_TYPE</code></td>
<td>日志记录类型</td>
<td>用于指定日志的记录方式，可选值如下：- <code>Console</code>：将日志输出到控制台，便于开发调试时实时查看日志信息。- <code>File</code>：将日志记录到文件中，并且文件会自动进行分片管理，方便日志的存储和后续分析。- <code>MongoDb</code>：使用 MongoDB 数据库来记录日志，适合需要对大量日志进行长期存储和复杂查询的场景。</td>
</tr>
<tr>
<td><code>LOG_MONGODB_SERVER_PATH</code></td>
<td>MongoDB 日志数据服务地址</td>
<td>仅当 <code>LOG_TYPE</code> 配置为 <code>MongoDb</code> 时需要配置该参数。它用于指定存储日志数据的 MongoDB 数据库服务的地址，确保日志能正确存储到指定的数据库中。</td>
</tr>
<tr>
<td><code>CACHE_TYPE</code></td>
<td>缓存类型</td>
<td>用于选择缓存的使用模式，可选值如下：- <code>Memory</code>：采用内存模式进行缓存，数据存储在服务器的内存中，读写速度快，但服务器重启后缓存数据会丢失，适合对缓存数据实时性要求较高且数据量较小的场景。- <code>Redis</code>：使用 Redis 服务进行缓存，数据存储在 Redis 服务器中，支持分布式缓存和持久化存储，适合对缓存数据可靠性和扩展性要求较高的场景。默认采用内存模式。</td>
</tr>
<tr>
<td><code>CACHE_REDIS_SERVER_PATH</code></td>
<td>Redis 缓存服务地址</td>
<td>仅当 <code>CACHE_TYPE</code> 配置为 <code>Redis</code> 时生效。该参数用于配置 Redis 服务的地址，以便服务能够连接到指定的 Redis 服务器进行缓存数据的读写操作。</td>
</tr>
<tr>
<td><code>DB_SERVER_URL</code></td>
<td>数据库连接地址</td>
<td>用于配置服务所连接的数据库的服务地址。通过该配置，服务可以正确连接到相应的数据库，实现数据的存储和读取操作。</td>
</tr>
</tbody>
</table>
<h3>如何创建变量</h3>
<p><img src="/workbench/env1.png" alt="环境配置界面"></p>
<p>我们可以在 <code>环境配置</code> 文件内容下方点击 <code>创建环境变量</code> 按钮来创建变量。</p>
<p><img src="/workbench/env2.png" alt="创建环境变量界面"></p>
<h4>变量配置项说明</h4>
<ul>
<li><strong>变量名</strong>：即环境变量的名称。在前端项目中，建议采用首字母小写驼峰命名规则；在服务端项目中，建议使用全大写且用 <code>_</code> 进行单词分割的命名规范。</li>
<li><strong>标题</strong>：该变量的标题，能辅助开发人员快速了解变量的含义。</li>
<li><strong>备注/提示</strong>：对变量的详细说明，有助于开发人员深入理解变量用途。</li>
<li><strong>变量分组</strong>：平台支持对变量进行分组管理，同一分组的变量会在环境配置文件中聚合展示，方便查看和管理。</li>
<li><strong>变量可选值</strong>：若变量存在可选值，可在此处填写，多个可选值按回车键添加。</li>
</ul>
<h3>如何创建环境</h3>
<p>我们可以在<code>环境配置</code>文件点击右上角的<code>创建环境</code>按钮来添加不同的环境。</p>
<p><img src="/workbench/env3.png" alt=""></p>
<p>创建完成后，会显示该环境的数据标签，通过切换环境来管理环境中的环境变量。</p>
<p><img src="/workbench/env4.png" alt=""></p>
<blockquote>
<p>DEV 环境是系统默认环境，不允许删除，DEV 环境即我们在开发时工作台运行环境。</p>
</blockquote>
<h3>如何使用环境变量</h3>
<p>在前端项目中我们通过<code>import.meta.define.</code>的方式去读取环境变量值。
<img src="/workbench/env5.png" alt=""></p>
<p>在服务端项目中我们通过<code>process.env.</code>的方式去读取环境变量值。
<img src="/workbench/env6.png" alt=""></p>
<h3>环境切换</h3>
<p>当我们配置好了多套环境变量，我们如何切换使用这些环境呢？ 这里我们提供了两种模式：调试运行、代码导出。</p>
<h4>调试运行</h4>
<p>我们可以在<a href="/workbench/debugger" target="_blank">运行调试</a> 时来选择环境进行运行调试。
<img src="/workbench/env7.png" alt=""></p>
<h4>代码导出</h4>
<p>在代码生成导出时，我们会在根目录生成这些环境变量的配置文件，并在<code>package.json</code>中提供不同环境的运行命令。</p>
<p><img src="/workbench/env8.png" alt=""></p>
<h3>数据安全</h3>
<p>针对环境配置文件，平台具备一套完整的数据安全保护机制。若你的项目是公开项目，当其他人员访问你的项目代码时，他们仅能看到环境变量，而环境变量的值会经过数据脱敏处理，从而确保你的环境变量值不会被泄露。</p>
<p>在进行项目克隆操作时，平台同样会对重要数据文件进行<strong>脱敏</strong>处理，全方位保障数据安全。</p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>