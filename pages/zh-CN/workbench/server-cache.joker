<template>
<div ref='container' class='joker-demo-container'>
<h2>缓存设计</h2>
<p>本章主要讲述在服务端应用如何实现缓存功能的开发，并介绍缓存功能的具体配置。</p>
<h3>概述</h3>
<p>缓存文件在服务端性能优化中发挥着关键作用，它能够帮助我们对热点数据进行缓存处理。通过缓存热点数据，有效避免了频繁访问数据库，从而减轻数据库服务压力，显著提升服务器性能，同时也加快了数据访问速度，极大地提高了用户访问效率。</p>
<p>我们可以在<strong>缓存</strong>文件夹中去创建我们的缓存文件。</p>
<p><img src="/workbench/back-end6.png" alt="缓存相关截图"></p>
<h3>缓存配置</h3>
<p>当打开缓存配置文件时，会发现平台已为我们提供了标准的缓存配置方案，其中包含以下配置要素：</p>
<ul>
<li><strong>缓存过期时间</strong>：可在此处配置缓存的过期时间。若不进行配置，则表示当前缓存永不过期。</li>
<li><strong>缓存类型</strong>：能够依据业务场景，配置不同的缓存类型：
<ol>
<li><strong>单项存储</strong>：主要提供简单直接的值操作，涵盖值的获取、设置与删除。借助这些基础操作，能迅速处理单个数据的缓存需求，适用于对单个数据频繁进行读写操作的缓存管理场景。</li>
<li><strong>数组存储</strong>：对外提供了一系列基于数组特性的缓存操作。不仅能获取缓存长度，了解当前缓存中数据项的数量；还可进行缓存插入，动态向缓存数组中添加新数据；若需清理缓存数组，可使用缓存清空功能；若要获取特定区间范围内的数据，可通过缓存列表（区间范围）操作来实现；并且，能够根据索引精准获取缓存中的数据，满足对数组型缓存数据多样化的访问需求。</li>
<li><strong>对象存储</strong>：提供了基于键值对的灵活缓存操作。可根据 Key 获取缓存，支持批量获取多个 Key 对应的缓存数据，大幅提升了数据获取效率；设置缓存时同样支持批量操作，便于一次性更新多个缓存数据；还能检查指定 Key 的缓存是否存在，方便在操作前确认数据状态；若需清理缓存，可执行删除缓存操作；此外，还能获取所有缓存 KEY，便于对缓存数据进行全面的管理与维护，适用于以对象形式组织和管理缓存数据的复杂业务场景。</li>
</ol>
</li>
<li><strong>数据类型</strong>：允许我们设计缓存项的数据类型，缓存的数据类型有助于我们在业务逻辑开发中更好地使用缓存中的值。</li>
<li><strong>缓存项加载方法</strong>：缓存支持手动通过调用方法来增加、修改、删除缓存。当然，平台也提供了自动缓存加载机制，其运行原理是：当查询缓存时，若缓存不存在，便会调用缓存加载方法，通过该方法完成缓存值的设定，从而免去手动配置的繁琐。</li>
</ul>
<h3>缓存加载方法</h3>
<p>缓存加载方法仅在缓存类型为<strong>单项存储</strong>和<strong>对象存储</strong>时可进行设置。借助该方法，我们能够实现数据库查询或进行复杂的计算，以此完成缓存值的加载。
<img src="/workbench/server-cache.png" alt=""></p>
<blockquote>
<p>该方法可通过<code>return</code>语句返回数据作为缓存值，返回值的类型需与缓存数据类型的设计要求相匹配。</p>
</blockquote>
<p>若不想使用缓存加载方法来配置缓存值，缓存也支持手动设置的方式。在<strong>逻辑编排</strong>中，可使用<strong>缓存操作</strong>节点来进行缓存操作，在此处完成缓存值的设置。
<img src="/workbench/server-cache1.png" alt=""></p>
<blockquote>
<p>不同的缓存类型会提供不同的交互方法。</p>
</blockquote>
<h3>如何使用缓存</h3>
<p>我们可以在<strong>逻辑编排</strong>中，可使用<strong>缓存操作</strong>节点来进行缓存操作。</p>
<p><img src="/workbench/server-cache2.png" alt=""></p>
<blockquote>
<p>这样操作的好处十分显著。当我们依据 id 获取用户信息时，系统会优先访问缓存。若缓存中命中所需数据，便会直接返回缓存数据，极大地节省了数据获取时间。若缓存未命中数据，缓存管理机制会自动调用缓存加载方法，从数据库中查询对应的值。在查询到数据后，会将其设置到缓存中，然后再返回我们所需的数据。通过这种方式，下次再进行相同的访问操作时，就可以直接从缓存中获取数据，无需再次消耗数据库的访问性能，有效提升了系统的整体响应速度和运行效率。</p>
</blockquote>
<h3>缓存存储方式</h3>
<p>平台为我们提供了两种缓存存储方式：</p>
<ol>
<li><strong>内存存储</strong>：把数据存放在业务服务内存里。其优势极为明显，无需借助其他硬件服务，直接在业务内存中进行读写操作，效率达到最高。不过，它也存在显著的局限性，一方面无法存储大量数据，另一方面当业务服务需要进行集群部署时，无法实现缓存的共享。</li>
<li><strong>Redis 缓存</strong>：平台支持通过简单配置来接入 Redis 缓存。这种缓存方式的优点众多，它能够存储大量的缓存数据，多台业务服务之间可以实现缓存共享。而且，随着业务量的不断增加，Redis 缓存还可以进行集群部署。但不足之处在于，Redis 服务需要进行部署安装，存在一定的技术门槛。</li>
</ol>
<p>我们可以在<strong>缓存配置</strong>文件中进行缓存存储方式的修改。</p>
<p><img src="/workbench/server-cache3.png" alt=""></p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>