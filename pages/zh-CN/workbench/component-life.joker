<template>
<div ref='container' class='joker-demo-container'>
<h2>组件生命周期</h2>
<p>本章主要介绍组件生命周期的创建和维护。</p>
<h3>如何创建和维护</h3>
<p>我们可以在<code>组件数据</code>面板中的<code>逻辑/事件 - 生命周期</code>中来管理我们的组件生命周期。当我们生命周期右侧的加号按钮后，可以添加生命周期函数。添加后，我们即可在这里维护我们的生命周期逻辑了。（逻辑编排帮助文档可以在<a href="/workbench/workflow" target="_blank">这里</a>中查看。）
<img src="/workbench/component2.png" alt=""></p>
<p>一个组件或者页面，从创建到销毁是由完整的一套生命周期函数的，我们可以通过这些函数来实现在不同节点中的业务处理。</p>
<p><img src="https://front.jokers.pub/base/component-life.png" alt=""></p>
<p>在默认的 Joker 体系下，一个组件的挂载和卸载都是一次性的，不存在状态保持，为了满足组件状态的保持，Joker 提供了 keep-alive 属性，可以主动让一个组件在调用 destroy 时，只销毁 DOM 节点，而不去销毁组件实例，当组件再次被装载时会使用存活实例重新 renderDOM，实现组件的状态保持。</p>
<p>针对以上的介绍，那这种保持状态的组件生命周期如下：</p>
<p><img src="https://front.jokers.pub/base/keepalive-life.png" alt=""></p>
<h3>列表</h3>
<table class="mkd-table">
<thead>
<tr>
<th>函数名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>组件创建后触发</td>
</tr>
<tr>
<td>mounted</td>
<td>组件渲染完毕并挂载 DOM 后触发</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>组件销毁前触发</td>
</tr>
<tr>
<td>destroyed</td>
<td>组件销毁后触发，作为生命周期最后一个钩子函数</td>
</tr>
<tr>
<td>sleeped</td>
<td>组件被睡眠后的钩子函数</td>
</tr>
<tr>
<td>weakup</td>
<td>组件被唤醒后触发的钩子函数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>逻辑编排教程请查看：<a href="/workbench/workflow" target="_blank">逻辑编排</a></p>
</blockquote>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>