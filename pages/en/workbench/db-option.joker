<template>
<div ref='container' class='joker-demo-container'>
<h2>Data Manipulation</h2>
<p>This chapter focuses on how to perform all kinds of database operations—covering basic Create, Read, Update, and Delete (CRUD) tasks, together with advanced grouping and aggregate-statistics queries. We concentrate on how to use the <strong>Database Operation</strong> node inside business-logic orchestrations.</p>
<h3>Overview</h3>
<p>During business orchestrations you can drag a <strong>Database Operation</strong> node onto the canvas to perform database-level actions.<br>
<img src="/workbench/db-option.png" alt=""></p>
<p>The steps are:</p>
<ol>
<li><strong>Select the target table</strong>: decide which database table you will act upon.</li>
<li><strong>Choose the action</strong>: after the table is fixed, pick the exact operation you want to execute against it.</li>
</ol>
<hr>
<h3>Inserting Data</h3>
<p>The platform offers two insertion modes: single-record insert and batch insert.</p>
<h4>Single-Record Insert</h4>
<p><img src="/workbench/db-option1.png" alt=""></p>
<p>When single-record mode is chosen, the platform auto-renders all mandatory columns for the selected table in the data panel so that you can assign values quickly. Additional optional columns can be added by clicking <strong>Additional Attributes</strong>.<br>
<img src="/workbench/db-option2.png" alt=""></p>
<h4>Batch Insert</h4>
<p>Batch insert expects an array of custom data items and the platform strictly validates the array’s type at design time.<br>
<img src="/workbench/db-option3.png" alt=""></p>
<hr>
<h3>Deleting Data</h3>
<p>Two deletion strategies are available: delete by index and delete by condition.</p>
<h4>Delete by Index</h4>
<p>Deletion by index is the fastest route.<br>
<img src="/workbench/db-option4.png" alt=""></p>
<p>Steps:</p>
<ol>
<li><strong>Pick the index</strong>: choose a single-column unique index or a composite index.</li>
<li><strong>Fill index value(s)</strong>: if the index is composite, supply all required values.</li>
</ol>
<h4>Delete Multiple Records by Condition</h4>
<p><img src="/workbench/db-option5.png" alt=""></p>
<p>The platform provides rich condition primitives:</p>
<ul>
<li><strong>Multiple constraints per column</strong></li>
<li><strong>Cross-table join conditions</strong></li>
<li><strong>AND/OR groupings</strong> to build arbitrarily complex predicates</li>
</ul>
<hr>
<h3>Updating Data</h3>
<p>Two update patterns exist: update a single record and update multiple records by condition.</p>
<h4>Update Single Record</h4>
<p>Index-based updates give top performance.<br>
<img src="/workbench/db-option6.png" alt=""></p>
<ol>
<li><strong>Select an index</strong> (unique or composite).</li>
<li><strong>Supply index value(s)</strong>.</li>
<li><strong>Configure the fields to change</strong> and assign new values.</li>
</ol>
<h4>Update Multiple Records by Condition</h4>
<p><img src="/workbench/db-option7.png" alt=""></p>
<p>Identical condition set supported as in <em>Delete Multiple</em>:</p>
<ul>
<li>Per-column multi-constraints</li>
<li>Cross-table joins</li>
<li>AND/OR grouped filters</li>
</ul>
<hr>
<h3>Querying Data</h3>
<p>Querying is the most frequent action. Choices are:</p>
<ul>
<li><strong>Query single record</strong></li>
<li><strong>Return first row</strong></li>
<li><strong>Query many by condition</strong></li>
<li><strong>Paginated query many by condition</strong></li>
<li><strong>Count rows by condition</strong></li>
</ul>
<h4>Query Single Record</h4>
<p>A lightning-fast index-based lookup.<br>
<img src="/workbench/db-option8.png" alt=""></p>
<ol>
<li><strong>Pick index</strong> (unique or composite).</li>
<li><strong>Fill index value(s)</strong>.</li>
<li><strong>Tick the columns to fetch</strong>.</li>
</ol>
<blockquote>
<p>Notice the built-in support for <strong>multi-table joins</strong>. The system <strong>auto-detects join relationships</strong> and presents them hierarchically. You can tick desired fields directly.</p>
</blockquote>
<blockquote>
<p>The underlying ORM will generate an optimized SQL query; unselected related tables incur <strong>zero overhead</strong>.</p>
</blockquote>
<h4>Return First Row</h4>
<p>Both <em>Query Single</em> and <em>Return First</em> return a single entity, but they differ:</p>
<ul>
<li><strong>Query Single</strong> uses an index and guarantees zero-or-one row.</li>
<li><strong>Return First</strong> applies a filter on any column(s), sorts the list, and takes the first item. Thus, performance is lower because predicates plus sorting occur.<br>
<img src="/workbench/db-option9.png" alt=""></li>
</ul>
<p>You can define <strong>rich filters</strong> and <strong>sort rules</strong>, making this far more flexible for ad-hoc requirements.</p>
<hr>
<h3>Filter Many Records by Condition</h3>
<p>Returns all matching rows as an <strong>Array</strong>.<br>
<img src="/workbench/db-option10.png" alt=""></p>
<p>Configuration knobs:</p>
<ul>
<li><strong>Range</strong>: skip &amp; limit offsets.</li>
<li><strong>Filters</strong>: per-column, cross-table, AND/OR nestings.</li>
<li><strong>Output columns</strong>: tick the exact fields you need including columns from joined tables.</li>
<li><strong>Sorting</strong>: multi-level with grouping rules.</li>
</ul>
<hr>
<h3>Paginated Query by Condition</h3>
<p>Built-in paging helper: supply <code>page</code> and receive one page.<br>
<img src="/workbench/db-option11.png" alt=""></p>
<p>Returned envelope:</p>
<pre><code class="language-js">// total number of matching rows
data.total;
// current page number
data.page;
// rows per page
data.pageSize;
// array of entities
data.list[0].email;
</code></pre>
<hr>
<h3>Count Rows by Condition</h3>
<p>Returns a <strong>Number</strong> (non-negative integer) of rows that satisfy the condition.<br>
<img src="/workbench/db-option12.png" alt=""></p>
<hr>
<h2>Advanced Operations</h2>
<p>The platform exposes three advanced utilities: <strong>Grouping Query</strong>, <strong>Upsert (Update-or-Insert)</strong>, and <strong>Aggregate Statistics Query</strong>.</p>
<h3>Upsert (Update or Insert)</h3>
<p>Looks up a record by index; if it exists—update, otherwise insert a new one.<br>
<img src="/workbench/db-option15.png" alt=""></p>
<h3>Grouping Query</h3>
<p>Grouping queries bucket data by one or more columns and run aggregate functions over each bucket inside the <em>Database Operation</em> node:</p>
<ol>
<li>Pick the target table.</li>
<li>Choose grouping columns.</li>
<li>Select aggregate functions (<code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, <code>AVG</code>).</li>
<li>Optionally add <strong>pre-filter</strong> and tick columns to output.<br>
<img src="/workbench/db-option13.png" alt=""></li>
</ol>
<p>Typical aggregates:</p>
<ul>
<li><strong>Count</strong>: records per group; <code>all</code>-based counter also available.</li>
<li><strong>Max/Min</strong>: largest/smallest value within each group.</li>
<li><strong>Sum</strong>: numeric columns only, returns total per group.</li>
<li><strong>Avg</strong>: numeric columns only, returns average per group.</li>
</ul>
<h3>Aggregate Query</h3>
<p>Performs statistical computation across rows (optionally after grouping) using available functions (<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>). Supports pre-filters and field-selection for the output.<br>
<img src="/workbench/db-option14.png" alt=""></p>
<h4>Grouping vs. Aggregate Concepts</h4>
<ul>
<li><strong>Grouping Query</strong>: core is <em>classification</em>. Rows with identical grouping key are gathered into the same bucket, enabling per-group operations.</li>
<li><strong>Aggregate Query</strong>: core is <em>statistical summarization</em>; may run over the whole dataset or over previously created groups.</li>
</ul>
<h5>Execution Flow</h5>
<ul>
<li>
<p><strong>Grouping</strong></p>
<ol>
<li>Define grouping key(s).</li>
<li>Run aggregate(s) on each bucket.<br>
Example: <em>Students</em> grouped by <em>class</em> → count students per class.</li>
</ol>
</li>
<li>
<p><strong>Aggregate</strong></p>
<ol>
<li>Either compute across whole table, or</li>
<li>Perform step 2 after grouping above.<br>
Example 1: overall average score.<br>
Example 2: average score per class (post grouping).</li>
</ol>
</li>
</ul>
<h5>Output Model</h5>
<ul>
<li><strong>Grouping + Aggregate</strong>: generates one row per group carrying the requested aggregates.</li>
<li><strong>Pure Aggregate</strong> (no grouping): single scalar or one-row summary.</li>
</ul>
<h5>Typical Use-Cases on the Platform</h5>
<ul>
<li><strong>Grouping Query</strong>: analyze how distinct product categories perform (group by <em>category</em>, aggregate <em>sales</em>).</li>
<li><strong>Aggregate Query</strong>: total salary for the entire company (no grouping) or mean salary per department (after grouping).</li>
</ul>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>