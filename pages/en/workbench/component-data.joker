<template>
<div ref='container' class='joker-demo-container'>
<h2>Component State Data</h2>
<p>This chapter focuses on <strong>component state data</strong>. Here you can maintain parameter constraints, internal reactive data, and private variables of a component.</p>
<h3>Overview</h3>
<p>Component state data is one of the most frequently used features in component development.</p>
<p><img src="/workbench/component.png" alt=""></p>
<p>When you open a <code>component</code> or <code>page</code> file, the <strong>Component Data</strong> entry appears on the left side of the Workbench. Click it to open the <strong>Component Data</strong> panel.</p>
<p>From a data-usage perspective, the data can be classified into three types: <strong>Input Props</strong>, <strong>Reactive Data (model)</strong>, and <strong>Internal Private Properties</strong>. The next sections describe their purposes and how to declare a property or parameter.</p>
<hr>
<h3>Input Props (props)</h3>
<p>These are the arguments required by the current component. They are <strong>reactive</strong>—whenever the caller passes new values, the component receives the update instantly and re-renders its DOM nodes. This makes the component highly flexible and reusable.<br>
For instance, a button component may accept text and color through props; when those props change, the button immediately reflects the new text or color.</p>
<blockquote>
<p>Configuration of input props is <strong>only available in component-type files</strong>. Page-type components do <strong>not</strong> allow prop configuration.</p>
</blockquote>
<h4>Creation / Edit</h4>
<p>Click the <strong>+</strong> icon on the right side of the <strong>Input Props</strong> panel to open the property-creation dialog. There you can specify the <strong>name</strong>, <strong>description</strong>, <strong>type</strong>, <strong>default value</strong>, and <strong>demo value</strong> of the prop.<br>
For step-by-step instructions, refer to the last section <strong>Creating &amp; Editing Properties / Parameters</strong>.</p>
<p><img src="/workbench/component-data.png" alt=""></p>
<h4>Usage</h4>
<p>After creation, the prop is ready for use from two distinct angles:</p>
<h5>1. Declarer’s View – Inside the Component</h5>
<ul>
<li>
<p><strong>Layout Template</strong>: Use <code>${props.variableName}</code> expressions to reference the prop.<br>
<img src="/workbench/component-data1.png" alt="Example of referencing a prop in template"></p>
</li>
<li>
<p><strong>Method Logic</strong>: In the <strong>logic editor</strong>, reference the value via <code>this.props.variableName</code>.<br>
<img src="/workbench/component-data2.png" alt="Example of referencing a prop in logic"></p>
</li>
</ul>
<blockquote>
<p><strong>Tip</strong>: If you are not comfortable writing code yet, don’t worry. The platform provides intelligent code completion and a <strong>Data Management Panel</strong> where you can click to insert variables quickly.</p>
</blockquote>
<h5>2. Consumer’s View – When Other Components or Pages Use It</h5>
<p>When another component or page references this component, simply select the component instance and open its <strong>Property Panel</strong>. All declared props appear there, ready for configuration.<br>
<img src="/workbench/component-data3.png" alt="Viewing declared props in a parent component"></p>
<blockquote>
<p><strong>Strong recommendation</strong>: Always <strong>fully declare</strong> the props. Provide descriptions, interaction types, and demo values so other developers can understand the prop’s intent at a glance.</p>
</blockquote>
<hr>
<h3>Reactive Data (model)</h3>
<p>These are the <strong>internal reactive values</strong> of the component. Before the component is mounted, they’re <strong>wrapped</strong> as reactive observers. Whenever any of these values change, the relevant parts of the component re-render automatically.<br>
Example: In a shopping-cart component, the item <strong>quantity</strong> is reactive—changing it instantly updates the displayed <strong>total price</strong> and the item list.</p>
<h4>Creation / Edit</h4>
<p>Click the <strong>+</strong> icon on the right side of the <strong>Reactive Data (model)</strong> panel. Configure <strong>name</strong>, <strong>description</strong>, <strong>type</strong>, <strong>default value</strong>, and <strong>demo value</strong> following the same workflow as above.<br>
See section “Creating &amp; Editing Properties/Parameters” for detailed steps.</p>
<p><img src="/workbench/component-data4.png" alt=""></p>
<h4>Understanding Reactive Data</h4>
<p>A simple <strong>DEMO</strong> helps illustrate the concept—when the reactive variable <code>count</code> is incremented by a button click, the DOM updates immediately.</p>
<DemoContainer component="@(components.DEMO_JOKER_demo1)">
<pre><code class="language-html">&lt;template&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;点我呀  [@(model.count)]&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;

export default class extends Component {
    model = {
        count: 0
    };

    //点击事件
    handleClick() {
        this.model.count++;
    }
}
&lt;/script&gt;

</code></pre>
</DemoContainer>
<h4>Usage</h4>
<p>Once defined:</p>
<ul>
<li>
<p><strong>Layout Template</strong>: Reference via <code>model.variableName</code> in expressions.<br>
<img src="/workbench/component-data5.png" alt="Example referencing model in template"></p>
</li>
<li>
<p><strong>Method Logic</strong>: Access via <code>this.model.variableName</code>.<br>
<img src="/workbench/component-data6.png" alt="Example referencing model in logic"></p>
</li>
</ul>
<blockquote>
<p><strong>Tip</strong>: Same as with props, smart completion and the <strong>Data Management Panel</strong> will help you insert variables without manual typing.</p>
</blockquote>
<hr>
<h3>Internal Private Properties</h3>
<p>Private properties are <strong>not</strong> accessible from the outside and are <strong>non-reactive</strong>. They make perfect temporary or utility variables within the component.<br>
For instance, a multi-step form component could hold a private <code>stepIndex</code> to track the current active step—only relevant inside the component’s methods.</p>
<h4>Creation / Edit</h4>
<p>Click the <strong>+</strong> on the right side of the <strong>Private Properties</strong> panel and fill in the <strong>name</strong>, <strong>description</strong>, <strong>type</strong>, <strong>default value</strong>, and <strong>demo value</strong> as described earlier.</p>
<p><img src="/workbench/component-data7.png" alt=""></p>
<p>Usage is identical to props or reactive data (expressions can read them directly), but remember:</p>
<ul>
<li>They <strong>do not trigger re-renders</strong>.</li>
<li>Therefore, <strong>never expose them in the template</strong> if the value can change at runtime.</li>
<li>Ideal for state that is shared among multiple methods without side effects introduced by reactivity.</li>
</ul>
<hr>
<h3>Creating &amp; Editing Properties / Parameters</h3>
<p>Here is a step-by-step guide to the property editor (parameters and reactive data share the same UI, but some options appear only for props).</p>
<h4>Step 1 – Basic Information</h4>
<p><img src="/workbench/component-data8.png" alt=""></p>
<ul>
<li><strong>Property Name</strong>: English letters; must be unique within its own scope (props, model or private).</li>
<li><strong>Title / Remarks</strong>: A human-readable label like Color, Size, etc.</li>
<li><strong>Tooltip</strong>: Detailed description that appears as a tooltip on hover.</li>
<li><strong>Category</strong>: Only <strong>for props</strong>; groups related props under a category.<br>
<img src="/workbench/component-data9.png" alt="Property categories"></li>
<li><strong>Sort Order</strong>: Determines order in the property panel; larger values appear first (<strong>props only</strong>).</li>
</ul>
<h4>Step 2 – Type Configuration</h4>
<p><img src="/workbench/component-data10.png" alt=""></p>
<ul>
<li>
<p><strong>Type</strong></p>
<ol>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Function</li>
<li>Date</li>
<li>Any</li>
</ol>
</li>
<li>
<p><strong>Required</strong>: Mark whether the value can be <code>undefined</code>.</p>
</li>
<li>
<p><strong>Value Assignment</strong> (props only) chooses how the consumer provides a value. Each data type exposes a different set of UI controls:</p>
<ol>
<li>Select (Key–Value options)</li>
<li>Multiline Text</li>
<li>Color Picker</li>
<li>CSS Dimension</li>
<li>Style Name Selector</li>
<li>Image Asset Selector</li>
<li>Asset Selector</li>
<li>Inline Style Editor</li>
<li>Expression (default)</li>
</ol>
</li>
<li>
<p><strong>Default Value</strong>: Applied if no value is supplied.</p>
</li>
<li>
<p><strong>Demo Value</strong> (props only): Immediately assigned when the component is dragged onto a page, providing a better first impression. Developers can still override it.</p>
</li>
</ul>
<p>When the property type is <strong>Array</strong> or <strong>Object</strong>, Step 2 displays a <strong>deep-type designer</strong> where you can further define nested properties/columns.</p>
<p><img src="/workbench/component-data11.png" alt=""></p>
<p>The nested designer shares the same options as above.</p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo1 from '../../../examples/workbench/component-data/demo1.joker';
export default class extends Component {
components={
BottomNav,
DEMO_JOKER_demo1
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>