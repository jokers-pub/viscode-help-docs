<template>
<div ref='container' class='joker-demo-container'>
<h2>Cache Design</h2>
<p>This chapter focuses on how to implement cache functionality development in server-side applications and introduces specific configurations for cache features.</p>
<h3>Overview</h3>
<p>Cache files play a critical role in server-side performance optimization, enabling the caching of hot data. By caching frequently accessed data, it effectively reduces frequent database queries, alleviating database server pressure and significantly improving server performance. This also accelerates data access speeds, greatly enhancing user access efficiency.</p>
<p>You can create cache files in the <strong>Cache</strong> folder.</p>
<p><img src="/workbench/back-end6.png" alt="Cache-related Screenshot"></p>
<h3>Cache Configuration</h3>
<p>When opening the cache configuration file, you will find that the platform has already provided a standardized cache configuration solution, which includes the following elements:</p>
<ul>
<li><strong>Cache Expiration Time</strong>: Configure the expiration time for the cache here. If left unconfigured, the cache will never expire.</li>
<li><strong>Cache Type</strong>: Configure different cache types based on business scenarios:
<ol>
<li><strong>Single-Item Storage</strong>: Provides simple and direct value operations, including value retrieval, setting, and deletion. These basic operations allow for quick handling of single-data caching needs, suitable for scenarios requiring frequent read/write operations on individual data.</li>
<li><strong>Array Storage</strong>: Offers a series of cache operations based on array characteristics. These include getting the cache length (to understand the number of data items), inserting data (adding new data dynamically), clearing the cache array, retrieving data within a specific range (via the &quot;cache list (range)&quot; operation), and accessing data precisely by index, catering to diverse access needs for array-type cached data.</li>
<li><strong>Object Storage</strong>: Provides flexible cache operations based on key-value pairs. These include retrieving cache by key (supporting batch retrieval for multiple keys to improve efficiency), setting cache (also supporting batch operations), checking if a specified key exists in the cache, deleting cache, and retrieving all cache keys for comprehensive management. This is ideal for complex business scenarios requiring object-form cache organization and management.</li>
</ol>
</li>
<li><strong>Data Type</strong>: Allows you to define the data type of cache items, which helps in better utilization of cached values during business logic development.</li>
<li><strong>Cache Loading Method</strong>: Cache supports manual methods to add, modify, or delete cache entries. Additionally, the platform provides an automatic cache loading mechanism. Its principle is: when querying the cache, if the data is absent, the cache loading method is invoked to set the cache value, eliminating the need for manual configuration.</li>
</ul>
<h3>Cache Loading Method</h3>
<p>The cache loading method can only be configured when the cache type is <strong>Single-Item Storage</strong> or <strong>Object Storage</strong>. Using this method, you can implement database queries or perform complex calculations to complete cache value loading.
<img src="/workbench/server-cache.png" alt=""></p>
<blockquote>
<p>This method can return data as the cache value via the <code>return</code> statement, and the returned value type must match the cache data type requirements.</p>
</blockquote>
<p>If you prefer not to use the cache loading method, manual configuration is also supported. In <strong>Logic Orchestration</strong>, you can use the <strong>Cache Operations</strong> node to perform cache operations and set cache values.
<img src="/workbench/server-cache1.png" alt=""></p>
<blockquote>
<p>Different cache types provide different interaction methods.</p>
</blockquote>
<h3>How to Use Cache</h3>
<p>You can use the <strong>Cache Operations</strong> node in <strong>Logic Orchestration</strong> to perform cache operations.</p>
<p><img src="/workbench/server-cache2.png" alt=""></p>
<blockquote>
<p>The benefits of this approach are significant. When fetching user information by ID, the system first checks the cache. If the data is present in the cache, it is returned directly, significantly reducing data retrieval time. If the data is not found in the cache, the cache management mechanism automatically invokes the cache loading method to query the corresponding value from the database. Once retrieved, the data is stored in the cache and then returned. This ensures that subsequent identical requests can be served directly from the cache, avoiding repeated database queries and improving overall system responsiveness and efficiency.</p>
</blockquote>
<h3>Cache Storage Methods</h3>
<p>The platform provides two cache storage methods:</p>
<ol>
<li><strong>In-Memory Storage</strong>: Stores data in the business service's memory. Its advantages are evidentâ€”it requires no additional hardware services, and read/write operations are performed directly in memory for maximum efficiency. However, it has notable limitations: it cannot store large amounts of data, and when business services require cluster deployment, cache sharing is not possible.</li>
<li><strong>Redis Cache</strong>: The platform supports easy configuration for Redis cache integration. This method offers numerous benefits, including the ability to store large amounts of cached data, enabling cache sharing across multiple business services. Moreover, as business demands grow, Redis cache can be deployed in a clustered setup. The downside is that Redis requires separate deployment and installation, posing a technical barrier.</li>
</ol>
<p>You can modify the cache storage method in the <strong>Cache Configuration</strong> file.</p>
<p><img src="/workbench/server-cache3.png" alt=""></p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>