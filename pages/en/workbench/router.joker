<template>
<div ref='container' class='joker-demo-container'>
<h2>Routing Management</h2>
<p>This chapter focuses on routing-related knowledge, covering topics such as <strong>Default Route Address</strong> and <strong>Routing Guards</strong>.</p>
<h3>Overview</h3>
<p><strong>Global Routing Management</strong> enables us to control the default access address of front-end applications while providing the ability to configure different <strong>Routing Guards</strong> based on business requirements.</p>
<p>Before diving into this chapter, we recommend reviewing the <a href="/workbench/page" target="_blank">Page Management</a> section.</p>
<p>You can maintain global routing configurations in the <strong>Routing Management</strong> panel within the <code>Project Configuration</code> file.</p>
<p><img src="/workbench/router.png" alt="Routing Management Panel Screenshot"></p>
<h3>Default Address</h3>
<p>Here, you can configure the default route address for the current project.</p>
<p>The platform automatically analyzes the routing context of all page resource files and lists the routing information for all leaf pages. You can select one of the addresses as the default page route. If left unconfigured, the default access path will be <code>/</code>. If your project does not include this route, runtime errors may occur.</p>
<p><img src="/workbench/router1.png" alt="Default Address Selection Interface Screenshot"></p>
<blockquote>
<p>Clicking the file name allows quick access to the target page resource, helping you understand how the route renders.</p>
</blockquote>
<h3>Routing Guards</h3>
<p>Routing Guards assist in executing diverse business requirements before or after route navigation, such as adding a loading state during redirection or performing login status checks beforehand.</p>
<h4>beforeRouteCallbacks [Before Navigation]</h4>
<p>In <code>beforeRouteCallbacks</code>, you can register listener functions to intercept pre-navigation events. This enables custom operations—like validating user permissions or logging—before routing occurs. This flexibility in controlling the navigation process helps optimize application performance and user experience.</p>
<p><img src="/workbench/router3.png" alt="beforeRouteCallbacks Operations Screenshot"></p>
<p>To redirect to another page before navigation, invoke the <code>next</code> function and pass the new target address to complete the redirection.</p>
<blockquote>
<p><strong>Important Note</strong>: The <strong>next</strong> function <strong>must</strong> be called. Pass a new address for redirection; otherwise, omit the parameter.</p>
</blockquote>
<h4>afterRouteCallbacks [After Navigation]</h4>
<p><code>afterRouteCallbacks</code> serves as a post-navigation hook, functioning similarly to <code>beforeRouteCallbacks</code>. However, it lacks flow-control mechanisms like <code>next</code> or <code>return</code>.</p>
<h3>Example</h3>
<p>Here, we demonstrate checking a user’s login status. If logged in, access proceeds; otherwise, the user is redirected to the login page.</p>
<p><img src="/workbench/router4.png" alt="Example Operation Screenshot"></p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>