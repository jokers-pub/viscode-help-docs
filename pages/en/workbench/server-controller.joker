<template>
<div ref='container' class='joker-demo-container'>
<h2>Controller Design</h2>
<p>This chapter focuses on the controller, a core functional module in server-side applications that is responsible for designing API interfaces, serving as the sole entry point for requests—a design hub for server-side applications.</p>
<h3>Overview</h3>
<p>The platform empowers users to rapidly create API interfaces for server-side applications through a visual interface. Within the <code>Controller</code> folder, developers can create different controllers based on business types, with each controller supporting multiple API methods.<br>
<img src="/workbench/back-end.png" alt=""></p>
<p>The explanation of controller functionalities will follow this sequence: <strong>API Creation → Input Parameters → API Method Parameters → API Method Return Types → Authentication</strong>.</p>
<h3>Creating an API</h3>
<p>In a controller file, multiple API methods can be created. Click the <strong>Create API</strong> button in the top-right corner to open the API editor window.<br>
<img src="/workbench/server-controller.png" alt=""></p>
<p>Within this window, the following configurations can be applied to an API interface:</p>
<ul>
<li><strong>Name</strong>: The name of the API method. Note that this is not the final API access URL, which follows the format: <code>service-root</code>/<code>controller-name</code>/<code>api-name</code>.</li>
<li><strong>Alias Title</strong>: A user-defined name for the API method to help developers quickly understand its purpose.</li>
<li><strong>Description</strong>: A detailed explanation of the API method for deeper comprehension.</li>
<li><strong>Request Type</strong>: Configures the allowed HTTP request method(s). Only requests matching the configured type(s) will map to this API method. Options include: <strong>POST</strong>, <strong>GET</strong>, <strong>PUT</strong>, <strong>DELETE</strong>.</li>
<li><strong>Authorization</strong>: When enabled, the system validates the JWT before accessing the API. If verification fails or the JWT expires, it returns a <strong>401</strong> error.</li>
<li><strong>Input Parameters</strong>: Configures API input parameters.</li>
</ul>
<h3>Input Parameter Validation</h3>
<p>As mentioned earlier, input parameters for API interfaces can be configured in the editor panel, following the general <strong>Field Management</strong> rules. Detailed documentation on this topic is available in the <a href="/workbench/property" target="_blank">Field Management</a> section.</p>
<p>Here, we highlight a special feature in <strong>Field Management</strong> for API input parameters: <strong>Input Parameter Validation</strong>.</p>
<p>In the second step of the <strong>Field Management</strong> editor window, different data types allow for varying constraint rules.<br>
<img src="/workbench/server-controller1.png" alt=""></p>
<p>Below are all validation rules, regardless of data type:</p>
<ol>
<li><strong>Regex Validation</strong>: Custom regex patterns for parameter constraints.</li>
<li><strong>Email Format</strong>: Ensures input matches email format.</li>
<li><strong>Phone Number Format</strong>: Validates phone number formatting.</li>
<li><strong>Alphabetic Only</strong>: Restricts input to letters only.</li>
<li><strong>Alphanumeric Only</strong>: Allows only letters and numbers.</li>
<li><strong>Numeric Only</strong>: Permits numeric strings (for string-type fields). For numeric fields, change the type directly—this rule supplements string-type validation.</li>
<li><strong>Integer Only</strong>: Requires strict integer input (no decimals).</li>
<li><strong>Contains Specific Content</strong>: Ensures the string contains predefined content.</li>
<li><strong>Value Range Restriction</strong>: Limits values (e.g., gender selection: male/female). Supports manual enumeration or table-based enums.<br>
<img src="/workbench/server-controller2.png" alt=""></li>
<li><strong>Length Restriction</strong>: Limits string length (min/max or combined).</li>
<li><strong>Maximum Value</strong>: Numeric field upper limit.</li>
<li><strong>Minimum Value</strong>: Numeric field lower limit.</li>
<li><strong>File Size Limit</strong>: For <strong>File</strong>-type fields, restricts upload size.</li>
<li><strong>File Format Limit</strong>: For <strong>File</strong>-type fields, limits the number of uploads (default: 1).</li>
<li><strong>File Type Limit</strong>: Restricts allowed file types for upload (supports wildcards, e.g., <code>image/jpeg, image/*</code>, with multiple types separated by commas).</li>
</ol>
<h3>File Upload</h3>
<p>In server-side projects, the <strong>Field Management</strong> panel supports selecting <strong>File</strong> as a field type, enabling file uploads via APIs.</p>
<p>Earlier sections introduced file-type constraints; here, we focus on <strong>File</strong>-type properties and operations.<br>
<img src="/workbench/server-controller3.png" alt=""></p>
<p>If an input parameter <code>userImg</code> is created, the uploaded file can be accessed via <code>data.userImg</code> and manipulated accordingly.</p>
<p>The <strong>File</strong> type provides the following attributes:</p>
<table class="mkd-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>checkMimeType</code></td>
<td>Function</td>
<td>Validates file type compliance (supports wildcards, e.g., <code>image/*</code> or array of types).</td>
</tr>
<tr>
<td><code>checkSize</code></td>
<td>Function</td>
<td>Validates file size compliance.</td>
</tr>
<tr>
<td><code>fileCount</code></td>
<td>Number</td>
<td>Number of files.</td>
</tr>
<tr>
<td><code>files</code></td>
<td>File[]</td>
<td>Array of all files.</td>
</tr>
<tr>
<td><code>save</code></td>
<td>Function</td>
<td>Saves files to a specified server directory.</td>
</tr>
</tbody>
</table>
<p>The <strong>save</strong> method is particularly important. Other properties are typically configured via constraints unless custom validation for file type/size is required.</p>
<h4>File Saving</h4>
<pre><code class="language-js">// Save directly to the default upload directory without modifications  
await data.userImg.save();  

// Full parameter example: Save to the 'user' subdirectory  
await data.userImg.save(&quot;user/&quot;, {  
    // Custom filename  
    newFileName: (file) =&gt; {  
        // Format: userId.ext (e.g., 123.jpg)  
        return userId + &quot;.&quot; + file.ext;  
    },  
    // Disable image compression (default: false)  
    uncompressedImage: false,  
    // Image compression settings (if enabled)  
    imageCompressionOption: {  
        // Quality (0–100, default: 80)  
        quality: 80,  
        // Max width in pixels (default: unlimited)  
        maxWidth: 1000,  
        // Max height in pixels (default: unlimited)  
        maxHeight: 1000  
    }  
});  
</code></pre>
<blockquote>
<p>The upload directory path can be configured via the <code>UPLOAD_ROOT_DIR</code> environment variable in server settings.</p>
</blockquote>
<h4>Save Method Return Value</h4>
<p>The <strong>save</strong> method returns an asynchronous response as an array:</p>
<pre><code class="language-typescript">{  
    success: string[];  // Array of successfully saved file paths  
    error: string[];    // Array of error messages for failed saves  
}  
</code></pre>
<p>Usage example:</p>
<pre><code class="language-js">let uploadResult = await data.userImg.save();  

if (uploadResult.error.length) {  
    // Log errors  
    return ActionError(&quot;Upload failed&quot;);  // ActionError is covered in the API Return Types section.  
}  

let userImg = uploadResult.success[0];  
</code></pre>
<p><img src="/workbench/server-controller4.png" alt=""></p>
<h3>API Method Parameters</h3>
<p>During API logic orchestration, the platform provides commonly used parameters:</p>
<ul>
<li><code>data</code>: Input parameters (defined in API configurations).</li>
<li><code>context</code>: Routing context data, including:
<ol>
<li><code>jwt</code>: Decrypted JWT payload (available only if authentication is enabled).</li>
<li><code>url</code>: Request URL.</li>
<li><code>request</code>: Raw request object (for IP, referrer, etc.).</li>
<li><code>logger</code>: Centralized logging object.</li>
</ol>
</li>
<li><code>logger</code>: For structured logging (file, console, or database), configurable in <a href="/workbench/env" target="_blank">Environment Settings</a>.</li>
</ul>
<h3>API Return Types</h3>
<p>The platform enforces a standardized response structure:</p>
<pre><code class="language-json">{  
    &quot;header&quot;: {  
        &quot;code&quot;: &quot;Status Code&quot;,  // &quot;JK000000&quot; indicates success; others denote errors.  
        &quot;msg&quot;: &quot;Error Message&quot;  
    },  
    &quot;data&quot;: {}  // Business data payload  
}  
</code></pre>
<h4>Helper Methods</h4>
<p><strong>Ok</strong><br>
Returns successful responses:</p>
<pre><code class="language-js">return Ok(businessData);  
</code></pre>
<p>Equivalent to the <strong>Return Success Data</strong> node in logic orchestration:<br>
<img src="/workbench/server-controller5.png" alt=""></p>
<p><strong>ActionError</strong><br>
Returns error responses:</p>
<pre><code class="language-js">return ActionError(errorMessage, errorCode, businessData);  
// errorCode defaults to &quot;JK999999&quot; if omitted.  
</code></pre>
<blockquote>
<p>Custom error codes enable frontend conditional handling.</p>
</blockquote>
<p>This can also be achieved via the <strong>Return Error Data</strong> node:<br>
<img src="/workbench/server-controller6.png" alt=""></p>
<h4>Fallback Handling</h4>
<p>In controllers, returning raw data (e.g., via <code>return</code>) triggers automatic wrapping with <code>Ok</code> if the response doesn't match the standard format.</p>
<h3>Authentication</h3>
<p>This section details JWT token configuration.</p>
<h4>Generating JWT Tokens</h4>
<p>Tokens are typically generated in login APIs using <code>generateJwtToken</code>:<br>
<img src="/workbench/server-controller7.png" alt=""></p>
<p>Key considerations:</p>
<ul>
<li>The example demonstrates user lookup and token generation.</li>
<li>Avoid storing sensitive data (e.g., passwords) in JWT payloads.</li>
</ul>
<h4>Frontend Token Submission</h4>
<p>Frontends must include the JWT in the <code>sid</code> header.</p>
<p>In the JOKER platform, <code>sid</code> can be injected globally via <code>transformReqData</code>:<br>
<img src="/workbench/server-controller8.png" alt=""></p>
<blockquote>
<p><strong>Important</strong>: For authenticated APIs, <code>context.jwt</code> provides the decoded payload. No manual <code>verifyJwtToken</code> call is needed—platform middleware handles validation. Use <code>verifyJwtToken</code> only for advanced custom validation.</p>
</blockquote>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>