<template>
<div ref='container' class='joker-demo-container'>
<h2>Logic Orchestration</h2>
<p>This chapter elaborates on the fundamental features of logic orchestration and how to leverage these capabilities to rapidly implement business logic.</p>
<h3>Overview</h3>
<p>Logic Orchestration is a visual development tool for methods. Within this tool, you can either use simple drag-and-drop operations or employ custom code blocks to implement business logic. The platform features robust <strong>type expressions</strong>, enabling quick access to required data variables at any logic node. Additionally, intelligent <strong>syntax hints</strong> and <strong>syntax checking</strong> functionalities make logic development more intuitive and smooth.</p>
<h3>How to Add Logic</h3>
<p>You can drag method nodes from the toolbox onto the canvas in the Logic Orchestration panel to invoke methods.</p>
<p><video width="80%" controls autoplay muted loop><source src="/workbench/workflow.mp4" type="video/mp4">你的浏览器不支持视频播放。</video></p>
<h3>How to Delete Logic</h3>
<p>Click the delete button on the right side of the node you wish to remove to delete the logic node.</p>
<p><img src="/workbench/workflow2.png" alt=""></p>
<h3>Adding Node Comments</h3>
<p>Click the edit comment button on the right side of the node to edit its comments.<br>
<img src="/workbench/workflow3.png" alt=""></p>
<blockquote>
<p>The edited comments will be exported to the actual generated code output.</p>
</blockquote>
<h3>Dragging Order</h3>
<p>Hover the mouse over the node you wish to move, select the drag icon, and hold the left mouse button to drag the node into position.</p>
<p><video width="80%" controls autoplay muted loop><source src="/workbench/workflow1.mp4" type="video/mp4">你的浏览器不支持视频播放。</video></p>
<h3>Logic Branching</h3>
<p>Logic branching allows you to visually implement <strong>if</strong>, <strong>else if</strong>, and <strong>else</strong> logic.</p>
<p><img src="/workbench/workflow4.png" alt=""></p>
<h3>Logging</h3>
<p>You can use the logging node to quickly output logs to the <code>console</code>.</p>
<p><img src="/workbench/workflow5.png" alt=""></p>
<blockquote>
<p>Note: In server-side projects, the server controller provides distributed logging capabilities, which are more powerful than console logging and allow flexible log output formats.</p>
</blockquote>
<h3>Internal Method Invocation</h3>
<p>This node enables visual internal method calls, automatically analyzing internal functions within the current project.</p>
<p><img src="/workbench/workflow6.png" alt=""></p>
<h4>Method Return Value Handling</h4>
<p>If the method has a return value, a variable reception operation icon will appear on the left side of the method call. Click it to configure the receiving variable.<br>
<img src="/workbench/workflow7.png" alt=""></p>
<p>You can choose to use an existing variable or create a new one to receive the return value.</p>
<p><img src="/workbench/workflow8.png" alt=""></p>
<h4>Method Parameters</h4>
<p>By default, the platform automatically identifies optional parameters and hides subsequent non-required (unconfigured) parameters. Click &quot;Expand More Parameters&quot; to reveal all parameters.</p>
<p><video width="80%" controls autoplay muted loop><source src="/workbench/workflow9.mp4" type="video/mp4">你的浏览器不支持视频播放。</video></p>
<h4>Asynchronous Methods (await)</h4>
<p>When invoking an asynchronous function, the method call node displays the option to enable <code>await</code>.</p>
<p>If <code>await</code> is enabled, the execution will wait for the method to complete successfully before continuing. If disabled, the logic will execute asynchronously without waiting for the result.</p>
<p><img src="/workbench/workflow10.png" alt=""></p>
<h3>Data Observation</h3>
<p>In frontend projects, you can use the data observation node in component-type files to monitor reactive value updates and receive notifications when values change.</p>
<p><img src="/workbench/workflow11.png" alt=""></p>
<p>This node's operation translates into the following code:</p>
<pre><code class="language-js">import { Component } from &quot;@joker.front/core&quot;;  

export default class extends Component {  
    model = {  
        value: &quot;v1&quot;  
    };  

    method() {  
        this.$watch(  
            () =&gt; this.model.icons,  
            (nv, ov) =&gt; {  
                console.info(&quot;Value changed&quot;);  
            }  
        );  
    }  
}  
</code></pre>
<p>Let’s explore this feature further with a demo.</p>
<DemoContainer component="@(components.DEMO_JOKER_demo1)">
<pre><code class="language-html">&lt;template&gt;
    &lt;p&gt;
        当前值: @model.value
    &lt;/p&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;将值变更为当前时间&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
import { Component } from &quot;@joker.front/core&quot;;
import { MessageBox } from &quot;@joker.front/ui&quot;;

export default class extends Component {
    model = {
        value: &quot;v1&quot;
    };

    mounted() {
        this.$watch(
            () =&gt; this.model.value,
            (nv, ov) =&gt; {
                MessageBox.alert(`值变更了：${ov}=&gt;${nv}`);
            }
        );
    }

    handleClick() {
        this.model.value = new Date().toLocaleTimeString();
    }
}
&lt;/script&gt;
</code></pre>
</DemoContainer>
<blockquote>
<p>For detailed usage, refer to the <code>$watch</code> method in the <a href="https://front.jokers.pub/base/component-api" target="_blank">Component Internal Methods</a> documentation.</p>
</blockquote>
<h3>Variable Declaration</h3>
<p>Use this node to declare new variables.</p>
<p><img src="/workbench/workflow12.png" alt=""></p>
<p>Equivalent to:</p>
<pre><code class="language-js">let age = 35;  
</code></pre>
<h3>Variable Assignment</h3>
<p>Use this node to assign values to existing variables.</p>
<p><img src="/workbench/workflow13.png" alt=""></p>
<h3>Loop Traversal</h3>
<p>This node enables looping through arrays or objects.</p>
<ul>
<li><strong>Loop Target</strong>: The object to loop through, which can be an array or an object.</li>
<li><strong>Loop Item</strong>: Defines the variable name for the loop item. For objects, this represents the property value; for arrays, it represents the array item.</li>
<li><strong>Loop Index</strong>: Defines the loop index variable. For objects, this represents the key; for arrays, it represents the index.</li>
</ul>
<p>To break out of the loop, use the <code>break</code> node or the <code>return</code> node directly.</p>
<p><img src="/workbench/workflow14.png" alt=""></p>
<p>The above logic is equivalent to:</p>
<pre><code class="language-js">for (let item of [1, 2, 3, 4]) {  
    console.info(item);  

    if (item &gt; 2) {  
        break;  
    }  
}  
</code></pre>
<h3>Return</h3>
<p>Use the return node to implement the <code>return</code> operation for methods. Click the button on the right to configure the return value.</p>
<p><img src="/workbench/workflow15.png" alt=""></p>
<h3>Custom Code Block</h3>
<p>The custom code block allows you to freely write code using <code>JavaScript</code> syntax.</p>
<p><img src="/workbench/workflow16.png" alt=""></p>
<p>Click the expand button on the right to open the expression editor, which provides more space for operations and displays all available variables for the current node.</p>
<p><img src="/workbench/workflow17.png" alt=""></p>
<blockquote>
<p>Note: Temporary variables declared within the code block are not recognized by subsequent node expressions. To make variables available later, declare them using the &quot;Define Variable&quot; node before the custom code block and assign values within the block. This design ensures better variable identification and debugging.</p>
</blockquote>
<h3>Debugging</h3>
<p>You can embed a <code>debugger</code> node in any logic node to facilitate debugging in the console.</p>
<p><img src="/workbench/workflow18.png" alt=""></p>
<blockquote>
<p>This node is removed during the actual code export/build process and can be safely used.</p>
</blockquote>
<h3>Triggering Events</h3>
<p>This node appears only in frontend component files. Use it to trigger component events.<br>
<img src="/workbench/workflow19.png" alt=""></p>
<blockquote>
<p>For detailed usage, refer to <a href="/workbench/component-event" target="_blank">Component Events</a>.</p>
</blockquote>
<h3>Component Access</h3>
<p>This node appears only in frontend component files. Use it to call methods of marked components.</p>
<p>Before using this node, ensure the target component has a <strong>Component Identifier</strong> property and exposes public methods.</p>
<p><img src="/workbench/workflow20.png" alt=""></p>
<p>Alternatively, you can use <code>this.$getRef</code> in a custom code block to access the component’s virtual node. This advanced usage offers more flexibility, including accessing internal data and registering component events.</p>
<pre><code class="language-js">import { Component } from &quot;@joker.front/core&quot;;  

export default class extends Component {  
    model = {  
        value: &quot;v1&quot;  
    };  

    method() {  
        this.$getRef(&quot;form1&quot;)?.component.submit();  
    }  
}  
</code></pre>
<h3>Environment Branching</h3>
<p>The platform divides development scenarios into three environments: development, debugging, and production. Use conditional logic to enable code for specific environments.</p>
<p><img src="/workbench/workflow21.png" alt=""></p>
<p>This functionality operates at the code generation level, not through runtime <code>if</code> checks.</p>
<blockquote>
<p>These environments are distinct from environment variables and are specific to development scenarios.</p>
</blockquote>
<h3>Internal Events</h3>
<p>Use the <strong>Internal Event Registration</strong> and <strong>Internal Event Removal</strong> nodes to manage internal component event handling.</p>
<p><img src="/workbench/workflow22.png" alt=""><br>
<img src="/workbench/workflow23.png" alt=""></p>
<h3>Batched Updates</h3>
<p>This node appears only in frontend projects. Use it to optimize DOM rendering when frequently modifying a variable. It batches changes and executes them once to avoid redundant updates.</p>
<blockquote>
<p>Before using this node, familiarize yourself with the JOKER framework’s <a href="https://front.jokers.pub/base/combined-reply" target="_blank">Batched Updates</a>.</p>
</blockquote>
<p>The platform provides quick batched update functionality:<br>
<img src="/workbench/workflow24.png" alt=""></p>
<p>Equivalent to:</p>
<pre><code class="language-js">combinedReply(() =&gt; {  
    this.model.radioValue = 1;  
    this.model.radioValue = 2;  
});  
</code></pre>
<h3>Data Synchronization</h3>
<p>This node appears only in frontend component files. Use it to quickly synchronize <code>props</code> values to <code>model</code> properties, updating the <code>model</code> when <code>props</code> change.</p>
<blockquote>
<p>The <code>props</code> and <code>model</code> property names must match.</p>
</blockquote>
<p><img src="/workbench/workflow25.png" alt=""></p>
<blockquote>
<p>For details, refer to the <strong>Property Synchronization (<code>$syncProp</code>)</strong> in <a href="https://front.jokers.pub/base/component-api" target="_blank">Component Internal Methods</a>.</p>
</blockquote>
<h3>Await DOM Update</h3>
<p>This node appears only in frontend component files. Use it to wait for DOM updates after changes, which is useful for asynchronous rendering.</p>
<p><img src="/workbench/workflow26.png" alt=""></p>
<blockquote>
<p>Joker frontend updates the DOM immediately upon property changes. However, when working with async components, use <code>$nextUpdatedRender</code> to confirm full rendering completion. For details, refer to <strong>Await Next Render</strong> in <a href="https://front.jokers.pub/base/component-api" target="_blank">Component Internal Methods</a>.</p>
</blockquote>
<h3>Return Success Data</h3>
<p>Appears only in server applications. Use this node to return successful response data.</p>
<p><img src="/workbench/workflow27.png" alt=""></p>
<p>Equivalent to:</p>
<pre><code class="language-js">return Ok(1);  
</code></pre>
<blockquote>
<p>This is a specialized <code>return</code> node with business semantics. Refer to <a href="/workbench/server-controller" target="_blank">Controller Design</a> for details.</p>
</blockquote>
<h3>Return Error Data</h3>
<p>Appears only in server applications. Use this node to return error response data.</p>
<p><img src="/workbench/workflow28.png" alt=""></p>
<p>Equivalent to:</p>
<pre><code class="language-js">return ActionError(&quot;Error message&quot;);  
</code></pre>
<blockquote>
<p>This is a specialized <code>return</code> node with business semantics. Refer to <a href="/workbench/server-controller" target="_blank">Controller Design</a> for details.</p>
</blockquote>
<h3>Database Operations</h3>
<p>Appears only in server applications. Use this node to perform database operations. For details, see <a href="/workbench/db-option" target="_blank">Database Operations</a>.</p>
<p><img src="/workbench/db-option.png" alt=""></p>
<h3>Cache Operations</h3>
<p>Appears only in server applications. Use this node to perform cache operations. For details, see <a href="/workbench/server-cache" target="_blank">Cache Operations</a>.</p>
<p><img src="/workbench/server-cache1.png" alt=""></p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
import DEMO_JOKER_demo1 from '../../../examples/workbench/workflow/demo1.joker';
export default class extends Component {
components={
BottomNav,
DEMO_JOKER_demo1
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>