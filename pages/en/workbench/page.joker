<template>
<div ref='container' class='joker-demo-container'>
<h2>Page Management</h2>
<p>This chapter focuses on how to maintain pages in &quot;Frontend - Application&quot; projects, achieve nested page layouts, and configure page routing information.</p>
<h3>Overview</h3>
<p><strong>Pages</strong> are indispensable file resources in &quot;Frontend - Application&quot; projects. They serve not only as the entry point for runtime execution but also as key functional files that determine the display effects for different URLs.</p>
<p>You can manage and view all page resources of your project in the <code>Pages</code> folder under the root directory.</p>
<p><img src="/workbench/page.png" alt=""></p>
<h3>Creating a Page</h3>
<p>You can create page files in the <code>Pages</code> folder.</p>
<p><img src="/workbench/page1.png" alt=""></p>
<p>Here, the following information needs to be provided:</p>
<ol>
<li><strong>Page Name</strong>: The file name of the page (in English letters).</li>
<li><strong>Remarks</strong>: An alias for the file to facilitate quick understanding of its purpose.</li>
<li><strong>Page Route</strong>: Configure the routing address for the page resource (details will be covered in later sections).</li>
</ol>
<h3>Creating a Layout File</h3>
<p>The platform provides a <strong>Layout File</strong> feature. Within <strong>Page Files</strong>, you can create <strong>Child Pages</strong> to generate layout files. A <strong>Layout Page</strong> is not a final <strong>routing address</strong> but rather a <strong>shared layout file</strong>. It consolidates <strong>common areas</strong> into a layout file while dynamically rendering <strong>variable content areas</strong> based on different child page URLs.</p>
<p>You can add a <strong>Page Container</strong> component to the parent page to mark the dynamic display area in the layout file. Then, create child pages under this resource file to achieve the requirement of displaying different child pages for different routes.</p>
<p><img src="/workbench/page2.png" alt=""></p>
<p>If you are a developer, the following code snippet may help you better understand layout files/nested routing:</p>
<pre><code class="language-js">export let router = new Router({  
    routes: [  
        {  
            path: &quot;/&quot;,  
            // Layout file  
            component: core,  
            children: [  
                {  
                    path: &quot;&quot;,  
                    component: index  
                },  
                {  
                    path: &quot;/about&quot;,  
                    component: about,  
                    theme: &quot;white&quot;  
                },  
                {  
                    path: &quot;/docs&quot;,  
                    component: docs  
                }  
            ]  
        }  
    ]  
});  
</code></pre>
<blockquote>
<p>Child pages inherit the routing information of their parent page. The prefix route information will be visible when creating a child page.</p>
</blockquote>
<p><img src="/workbench/page3.png" alt=""></p>
<h3>Child Components</h3>
<p>Although the platform has a unified <code>Components</code> folder, it may not be suitable for <strong>private components</strong> specific to a <strong>page</strong> or <strong>module</strong> to be placed in the root <strong>Components</strong> folder. To address this, the platform allows you to create <strong>Component-Type Files</strong> under <strong>Page Resources</strong>. These component files follow the same development pattern as <strong>public components</strong>, with the only difference being that they are recommended for use only within the <strong>current level</strong> and <strong>sub-level pages or components</strong>. If this usage hierarchy is violated, the platform will issue a warning. This helps better manage the needs for both <strong>private components</strong> and <strong>public components</strong>.</p>
<p><img src="/workbench/page4.png" alt=""></p>
<blockquote>
<p>To better distinguish private components from public components, their icons are differentiated in the interface.</p>
</blockquote>
<h3>Configuring Routing Information</h3>
<p>During file creation, whether for <strong>Layout Page Files</strong> or final <strong>Route Page Files</strong>, you can configure their <strong>routing information</strong> either at creation or during maintenance.</p>
<p>Simply click the <strong>plus sign</strong> next to the <strong>Route Address</strong> to add routing information. Note that the <strong>Route Address</strong> is divided into multiple segments using <code>/</code>, allowing the creation of multi-level routes.</p>
<p><img src="/workbench/page5.png" alt="Route Information Addition Interface"></p>
<p>After clicking to add a route segment, a route segment editing window will appear.</p>
<p><img src="/workbench/page6.png" alt="Route Segment Editing Window Interface"></p>
<ul>
<li><strong>Route Segment</strong>: Define the route segment using English letters.</li>
<li><strong>Dynamic Parameter</strong>: Indicate whether the current route segment is a dynamic parameter.</li>
</ul>
<p>For example, to configure a route address like <code>/info/:id</code>, you need to set <code>id</code> as a dynamic parameter. When configuring dynamic parameters, the platform supports setting the parameter title, optional status, MOCK data, and other related information.</p>
<p><img src="/workbench/page7.png" alt="Dynamic Parameter Configuration Interface"></p>
<ul>
<li><strong>Title</strong>: Assign an alias to the dynamic parameter to help developers quickly understand its meaning.</li>
<li><strong>Is Optional Parameter</strong>: If set as optional, the parameter can be empty or omitted. For instance, with the route address <code>/info/:id</code>, both <code>/info/123</code> and <code>/info</code> will match the page.</li>
<li><strong>Parameter MOCK</strong>: Maintain a Mock value here to prevent errors during development due to missing parameters.</li>
</ul>
<blockquote>
<p>In some scenarios, the <strong>Route Address</strong> can be left blank. If not specified, the system will generate the actual route address for the leaf page based on the hierarchical routing relationships.</p>
</blockquote>
<blockquote>
<p>For features related to global routing configuration, refer to <a href="/workbench/router" target="_blank">Route Management</a>.</p>
</blockquote>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>