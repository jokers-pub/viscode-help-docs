<template>
<div ref='container' class='joker-demo-container'>
<h2>Understanding the Server Side</h2>
<p>This chapter focuses on the capabilities of the <strong>server-side project</strong> and the convenient development features it delivers.</p>
<p>JOKER embraces a <strong>front-end/back-end decoupled</strong> architecture, granting developers the flexibility to choose their area of expertise. Depending on individual strengths and project requirements, they can fully concentrate on either the front-end or the server-side. This document narrows in on the server side, providing an in-depth explanation of its features to help readers master server-focused development within the JOKER platform.</p>
<h3>Overview</h3>
<p>The server-side project is the <strong>critical data-processing layer</strong> indispensable to any modern web application—acting as the invisible “data steward” behind the scenes. Its mission is to manage and manipulate large volumes of data efficiently, ensuring rock-solid data services for the front end.</p>
<p>In the server-development space, JOKER’s <strong>intelligent development platform</strong> opens the door to flexible coding. By leveraging its <strong>visual code builder</strong>, developers can complete all server-side assets without writing boilerplate SQL or boilerplate Node.js code. Examples include:</p>
<ul>
<li>Designing database table structures as intuitively as snapping LEGO blocks together—defining relationships, composite keys, and composite indexes in minutes.</li>
<li>Declaring controllers (API endpoints) visually while enforcing request/response contracts, ensuring seamless front-end/back-end data exchange.</li>
<li>Configuring caching layers in drag-and-drop fashion to accelerate read/write operations and slash database contention.</li>
</ul>
<p><img src="/workbench/back-end.png" alt="Server-side visual workbench"></p>
<h3>Component Files</h3>
<p>A complete server-side application comprises several file types working in concert:</p>
<ul>
<li><strong>Data Models</strong> – Design entire database schemas visually. Supports complex business rules such as table relations, PK definition, composite and unique indexes, etc.</li>
<li><strong>Controllers</strong> – The public contract layer. Exposes APIs and business logic, powered by <code>@joker.server/core</code>. Includes visual JWT setup, RBAC, input sanitisation, and security audits.</li>
<li><strong>Caching</strong> – Caches hot data to cut database traffic, raise throughput and maintain responsiveness under high concurrency.</li>
<li><strong>Configuration Files</strong> – Single source of truth for global settings, reusable styles, component/method visibility, route mapping, environment variables, and NPM references.</li>
<li><strong>Environment Variables</strong> – Isolate dev/test/prod behaviour by injecting different values without modifying code.</li>
</ul>
<hr>
<h3>Data Models</h3>
<p>Select <strong>Database</strong> in the left sidebar to open the <strong>Data Model Designer</strong>. Table schemas appear graphically for easy management.</p>
<p><img src="/workbench/back-end2.png" alt="Schema Designer"></p>
<p>Relation mapping is astonishingly simple: the platform auto-detects types and completes foreign-key bindings automatically. A built-in schema linter flags design issues instantly and suggests fixes.</p>
<p><img src="/workbench/back-end3.png" alt="Schema linter"></p>
<blockquote>
<p><strong>Info</strong>: Under the hood, Prisma with <strong>PostgreSQL</strong> is the default stack, enabling <strong>schema sync</strong> and <strong>auto-migration</strong> for frictionless life-cycle management.</p>
</blockquote>
<hr>
<h3>Controllers</h3>
<p>Controllers are the gateway layer. Through the visual editor you declare REST endpoints and map them to server-side logic—either inline in the controller or via reusable <strong>method collections</strong> for clean layering.</p>
<p><img src="/workbench/back-end4.png" alt="Controller editor"></p>
<p>The IDE provides:</p>
<ul>
<li>One-click REST method selection (GET/POST/PUT/PATCH/DELETE).</li>
<li>One-click JWT authentication toggle.</li>
<li>Visual query builders for single-table, multi-table JOIN, GROUP BY, aggregation, and pagination pipelines.</li>
</ul>
<p><img src="/workbench/back-end5.png" alt="Visual query builder"></p>
<hr>
<h3>Caching</h3>
<p>Cache files enable high-speed retrieval of hot data, eliminating repetitive database hits and cutting average response latency.</p>
<p><img src="/workbench/back-end6.png" alt="Cache editor"></p>
<p>JOKER currently supports <strong>three cache topologies</strong> (more coming soon):</p>
<ul>
<li><strong>Single Value</strong> – Basic get/set/del operations for atomic data.</li>
<li><strong>Array/List</strong> – Push, pop, len, range slice, index lookup, clear.</li>
<li><strong>Object/Hash</strong> – Key-value store with batch get, batch set, exists, del, list keys—all suited for hierarchical cache objects.</li>
</ul>
<hr>
<h3>Configuration Files</h3>
<p>Every <strong>Repository</strong> contains a <strong>project config</strong> file governing shared metadata.</p>
<p><img src="/workbench/back-end7.png" alt="Project Config editor"></p>
<p>Depending on the project type, the file exposes:</p>
<h4>NPM Package Management</h4>
<p>Install underlying libraries here to tap into third-party capabilities—unlike the <em>Component &amp; Method Marketplace</em>, which exposes pre-packaged visual assets.</p>
<p><img src="/workbench/back-end8.png" alt="NPM tab"></p>
<h4>Global Variables</h4>
<p>Define truly global, runtime-safe constants that every part of the application can reach.</p>
<p><img src="/workbench/back-end9.png" alt="Global Variables"></p>
<hr>
<h3>Environment Variables</h3>
<p>The platform ships with full-featured environment management.</p>
<p><img src="/workbench/back-end10.png" alt="Env Variables"></p>
<p>Create multiple named environments—e.g., <code>dev</code>, <code>staging</code>, <code>prod</code>—and assign custom key/value pairs. Access them via <code>process.env.KEY</code> anywhere in code.</p>
<p><img src="/workbench/back-end11.png" alt="Env Editor"></p>

<BottomNav />
</div>
</template>
<script>
import { Component } from "@joker.front/core";
import hljs from "highlight.js/lib/common";
import BottomNav from "../../../common/components/bottom-nav.joker";
export default class extends Component {
components={
BottomNav
}
mounted(){
let container= this.$getRef('container')?.output!;
container.querySelectorAll('pre code').forEach((el:HTMLElement) => {
        hljs.highlightElement(el);
      });
}
}
</script>